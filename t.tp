-- Example tprob file.

data Bool = True | False

-- "sig" introduces value typing annotations at the top level that is in scope
-- for the rest of the toplevel declarations.
-- We don't require a definition for every "sig" and so we can use the
-- definitions to talk about functions we haven't implemented (or which we assume are primitive)
sig or :: Bool -> Bool -> Bool
sig eqInt :: Int -> Int -> Bool
sig boolToInt :: Bool -> Int

data T (a :: ⋆) = L a | R a

data Mu (c :: ⋆ → ⋆) = Mu (c (Mu c))

-- sig declarations declare the type of an identifier.
sig tToM :: forall (a ∷ ⋆) (m ∷ ⋆ → ⋆) . T a → m a

-- There's also an ASCII syntax
sig id :: forall (a :: *) . a -> a

-- fun declarations provide a definition.
fun id x = id x

sig swap :: forall (a :: *) (b :: *) (g :: *) . a -> b -> (b -> a -> g) -> g

fun swap x y κ = κ y x

sig flip :: Real -> Dist Bool

fun h i = -- bindings are of the form v or (v :: ty)
  let
    { (fair :: Real) = 0.5      {- value assignment -}
    ; (biased :: Real) = 0.9
    ; x ~ flip fair   {- sampling from a distribution -}
    ; y ~ flip biased
    }
  in or x y


----- enumeration types
enum Five 5

sig eqFive :: Five -> Five -> Bool

sig one :: Five

sig isOne :: Five -> Bool
fun isOne x = eqFive x one


